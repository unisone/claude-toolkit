# Git Worktree Patterns for AI Coding

## Multi-Agent Parallel Development

### Pattern 1: Feature + Tests + Docs

```bash
# Setup three worktrees for parallel work
worktrees ~/Projects/my-app feature tests docs

# Add aliases to ~/.zshrc
alias za='cd ~/Projects/my-app-feature'
alias zb='cd ~/Projects/my-app-tests'
alias zc='cd ~/Projects/my-app-docs'

# Now spawn sub-agents, each in their own worktree
# Agent 1: Feature implementation
claude spawn --label feature --workdir ~/Projects/my-app-feature \
  "Implement user authentication with OAuth"

# Agent 2: Write tests
claude spawn --label tests --workdir ~/Projects/my-app-tests \
  "Write comprehensive tests for OAuth flow"

# Agent 3: Documentation
claude spawn --label docs --workdir ~/Projects/my-app-docs \
  "Document OAuth setup and API endpoints"

# Agents work in parallel, no conflicts!
# Merge when ready:
cd ~/Projects/my-app-feature
git push origin worktree/feature

cd ~/Projects/my-app-tests  
git push origin worktree/tests

cd ~/Projects/my-app-docs
git push origin worktree/docs

# Create PRs, merge to main
```

### Pattern 2: Bug Fix While Building

```bash
# Already working on a feature in main repo
cd ~/Projects/my-app
# Building new dashboard...

# Production bug comes in! Don't lose context.
# Create hotfix worktree
git worktree add ../my-app-hotfix main

# Fix the bug in isolation
cd ~/Projects/my-app-hotfix
# Fix, test, commit, push

# Delete worktree, back to feature work
cd ~/Projects/my-app
git worktree remove ../my-app-hotfix

# No branch switching, no rebuild, context preserved!
```

### Pattern 3: Comparison/Analysis Worktree

```bash
# Setup analysis worktree (stays on main)
worktrees ~/Projects/my-app experiment

# In experiment worktree: try risky refactor
cd ~/Projects/my-app-experiment
# Aggressive refactoring...

# In main worktree: always have clean reference
cd ~/Projects/my-app
# Check original implementation
# Compare file-by-file with:
diff ~/Projects/my-app/src/component.ts ~/Projects/my-app-experiment/src/component.ts

# Keep or discard experiment without affecting main
```

### Pattern 4: Multi-Framework Testing

```bash
# Testing migration from React to Vue
worktrees ~/Projects/my-app react-version vue-version

# Both implementations side-by-side
cd ~/Projects/my-app-react-version
npm run dev  # Runs on localhost:3000

cd ~/Projects/my-app-vue-version  
npm run dev  # Runs on localhost:3001

# Compare performance, bundle size, DX
# Choose winner, discard loser
```

## Claude Code Integration

### Spawn Sub-Agents with Worktrees

```bash
# Setup worktrees
worktrees ~/Projects/api backend frontend devops

# Launch parallel agents
claude spawn --label "backend" \
  --workdir ~/Projects/api-backend \
  "Implement REST endpoints for user management"

claude spawn --label "frontend" \
  --workdir ~/Projects/api-frontend \
  "Build UI for user management dashboard"

claude spawn --label "devops" \
  --workdir ~/Projects/api-devops \
  "Setup Docker + K8s deployment configs"

# Check progress
claude status

# All agents working independently!
# No merge conflicts until you explicitly merge branches
```

### Session Isolation

```bash
# Each worktree = isolated development session
# Perfect for testing different approaches

worktrees ~/Projects/app approach-a approach-b approach-c

# Try approach A
cd ~/Projects/app-approach-a
claude "Implement feature using hooks"

# Try approach B  
cd ~/Projects/app-approach-b
claude "Implement same feature using classes"

# Try approach C
cd ~/Projects/app-approach-c  
claude "Implement same feature with state machines"

# Compare, pick best, discard others
```

## Aliases for Quick Navigation

Add to `~/.zshrc` or `~/.bashrc`:

```bash
# Project-specific aliases (generated by worktrees script)
alias za='cd ~/Projects/my-app-feature'
alias zb='cd ~/Projects/my-app-tests'
alias zc='cd ~/Projects/my-app-docs'

# Quick list all worktrees
alias wtlist='git worktree list'

# Jump to main repo
alias zm='cd ~/Projects/my-app'

# Clean status across all worktrees
alias wtstatus='git worktree list | awk "{print \$1}" | xargs -I {} sh -c "echo \"=== {} ===\" && git -C {} status -s"'

# Pull all worktrees
alias wtpull='git worktree list | awk "{print \$1}" | xargs -I {} git -C {} pull'
```

## Cleanup Strategies

### Temporary Experiment

```bash
# Quick experiment, delete immediately
git worktree add ../my-app-experiment
cd ../my-app-experiment
# ... test something ...
cd ../my-app
git worktree remove ../my-app-experiment
# Gone forever, no branch pollution
```

### Keep Branch, Remove Worktree

```bash
# Finished feature, want to keep branch
cd ~/Projects/my-app
git worktree remove ../my-app-feature
# Branch still exists: git branch -a shows worktree/feature
# Can checkout later: git checkout worktree/feature
```

### Full Cleanup

```bash
# Remove worktrees AND branches
worktrees --clean ~/Projects/my-app --force

# Or manually:
cd ~/Projects/my-app
git worktree remove ../my-app-feature
git branch -D worktree/feature
```

## Best Practices

### 1. Main Repo = Read-Only Reference

```bash
# Never work directly in main repo after setup
# Use it only for:
# - Pulling latest main
# - Creating new worktrees
# - Checking clean reference code
```

### 2. One Worktree Per Task

```bash
# Good
worktrees ~/Projects/app auth-flow payment-flow

# Bad (too granular)
worktrees ~/Projects/app button-fix typo-fix import-fix
```

### 3. Short-Lived Worktrees

```bash
# Worktrees are for parallel development, not permanent
# Merge and delete when task is complete

# Daily workflow:
# 1. Morning: Create worktree for today's task
# 2. Work: Develop, commit, push
# 3. Evening: Create PR, clean up worktree
# 4. Repeat
```

### 4. Naming Convention

```bash
# Use descriptive worktree names
worktrees ~/Projects/api \
  oauth-implementation \
  rate-limiting \
  graphql-migration

# Avoid generic names
worktrees ~/Projects/api feature1 feature2 fix  # Bad
```

### 5. Sync with Main

```bash
# Periodically sync worktrees with main
cd ~/Projects/my-app-feature
git fetch origin main
git rebase origin/main
# Resolve conflicts in isolation
```

## Common Pitfalls

### ❌ Forgetting Which Worktree You're In

```bash
# Solution: Update your prompt to show worktree
# Add to ~/.zshrc:
setopt PROMPT_SUBST
parse_git_worktree() {
  local worktree=$(basename $(git rev-parse --show-toplevel 2>/dev/null) 2>/dev/null)
  [[ -n "$worktree" ]] && echo "[$worktree]"
}
PS1='%~ $(parse_git_worktree) $ '
```

### ❌ Leaving Uncommitted Changes

```bash
# Always commit or stash before switching
cd ~/Projects/my-app-feature
git status
git add . && git commit -m "wip: checkpoint"
# Now safe to switch worktrees
```

### ❌ Too Many Worktrees

```bash
# Keep it manageable (3-5 max)
# More than that = context overload

# Check current worktrees
git worktree list

# Clean up old ones
worktrees --clean ~/Projects/my-app
```

## Advanced: Dynamic Worktree Creation

```bash
#!/bin/bash
# create-task-worktree.sh - Create worktree from Jira ticket

TICKET=$1
REPO_PATH=$2

if [[ -z "$TICKET" || -z "$REPO_PATH" ]]; then
  echo "Usage: $0 <TICKET-123> <repo-path>"
  exit 1
fi

PARENT_DIR=$(dirname "$REPO_PATH")
REPO_NAME=$(basename "$REPO_PATH")
WORKTREE_PATH="$PARENT_DIR/${REPO_NAME}-${TICKET}"

cd "$REPO_PATH"
git worktree add -b "feature/$TICKET" "$WORKTREE_PATH" main

echo "Worktree created: $WORKTREE_PATH"
echo "Branch: feature/$TICKET"
echo "Next: cd $WORKTREE_PATH"
```

Usage:

```bash
./create-task-worktree.sh PROJ-123 ~/Projects/my-app
cd ~/Projects/my-app-PROJ-123
# Start coding
```
